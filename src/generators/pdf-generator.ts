import { promises as fs, createWriteStream } from 'node:fs';
import { dirname } from 'node:path';
import PDFDocument from 'pdfkit';
import type { JobListing } from '../parsers/schemas/job.schema.js';
import { createLogger } from '../utils/logger.js';

const logger = createLogger({ module: 'pdf-generator' });

/**
 * PDF report generation options
 */
export interface PdfGeneratorOptions {
  outputPath: string;
  title?: string;
  metadata?: {
    author?: string;
    subject?: string;
    keywords?: string;
    creator?: string;
  };
  layout?: {
    includeCharts?: boolean;
    includeAnalytics?: boolean;
    includeJobDetails?: boolean;
    theme?: 'default' | 'minimal' | 'detailed';
  };
  filters?: {
    maxJobs?: number;
    includeDescription?: boolean;
    includeRequirements?: boolean;
    includeBenefits?: boolean;
  };
}

/**
 * PDF report generation utilities
 */
export class PdfGenerator {
  private static readonly PAGE_MARGIN = 50;
  private static readonly PRIMARY_COLOR = '#2563eb';
  private static readonly SECONDARY_COLOR = '#64748b';
  private static readonly SUCCESS_COLOR = '#10b981';

  /**
   * Generate a comprehensive PDF report from job listings
   */
  static async generateReport(jobs: JobListing[], options: PdfGeneratorOptions): Promise<void> {
    try {
      // Ensure output directory exists
      await fs.mkdir(dirname(options.outputPath), { recursive: true });

      // Create PDF document
      const doc = new PDFDocument({
        margin: PdfGenerator.PAGE_MARGIN,
        info: {
          Title: options.title || 'Job Search Report',
          Author: options.metadata?.author || 'Job Dorker',
          Subject: options.metadata?.subject || 'Job listings and analytics report',
          Keywords: options.metadata?.keywords || 'jobs, career, search, analysis',
          Creator: options.metadata?.creator || 'Job Dorker v1.0.0',
          Producer: 'PDFKit',
          CreationDate: new Date(),
        },
      });

      // Create write stream
      const stream = doc.pipe(createWriteStream(options.outputPath));

      // Generate report content
      await PdfGenerator.generateContent(doc, jobs, options);

      // Finalize PDF
      doc.end();

      // Wait for stream to finish
      await new Promise<void>((resolve, reject) => {
        stream.on('finish', () => resolve());
        stream.on('error', reject);
      });

      // Get file size
      const stats = await fs.stat(options.outputPath);

      logger.info(
        {
          outputPath: options.outputPath,
          jobCount: jobs.length,
          fileSize: stats.size,
          pages: doc.bufferedPageRange().count,
        },
        'PDF report generated successfully',
      );
    } catch (error) {
      logger.error({ error, outputPath: options.outputPath }, 'Failed to generate PDF report');
      throw error;
    }
  }

  /**
   * Generate PDF content
   */
  private static async generateContent(
    doc: typeof PDFDocument.prototype,
    jobs: JobListing[],
    options: PdfGeneratorOptions,
  ): Promise<void> {
    const layout = options.layout || {};
    const filters = options.filters || {};

    // Title page
    PdfGenerator.generateTitlePage(doc, jobs, options);

    // Executive summary
    if (layout.includeAnalytics !== false) {
      doc.addPage();
      PdfGenerator.generateExecutiveSummary(doc, jobs);
    }

    // Analytics and charts
    if (layout.includeCharts !== false) {
      doc.addPage();
      PdfGenerator.generateAnalytics(doc, jobs);
    }

    // Job listings
    if (layout.includeJobDetails !== false) {
      const jobsToInclude = filters.maxJobs ? jobs.slice(0, filters.maxJobs) : jobs;

      PdfGenerator.generateJobListings(doc, jobsToInclude, filters);
    }

    // Footer on all pages
    PdfGenerator.addFooters(doc);
  }

  /**
   * Generate title page
   */
  private static generateTitlePage(
    doc: typeof PDFDocument.prototype,
    jobs: JobListing[],
    options: PdfGeneratorOptions,
  ): void {
    const centerX = doc.page.width / 2;

    // Main title
    doc
      .fillColor(PdfGenerator.PRIMARY_COLOR)
      .fontSize(32)
      .text(options.title || 'Job Search Report', centerX - 150, 150, {
        width: 300,
        align: 'center',
      });

    // Subtitle
    doc
      .fillColor(PdfGenerator.SECONDARY_COLOR)
      .fontSize(16)
      .text('Generated by Job Dorker', centerX - 100, 200, {
        width: 200,
        align: 'center',
      });

    // Report statistics
    const stats = PdfGenerator.calculateBasicStats(jobs);
    const y = 280;

    doc
      .fillColor('#000000')
      .fontSize(14)
      .text(`Total Jobs Found: ${stats.totalJobs}`, centerX - 150, y)
      .text(`Companies: ${stats.companiesCount}`, centerX - 150, y + 25)
      .text(`Locations: ${stats.locationsCount}`, centerX - 150, y + 50)
      .text(`Remote Jobs: ${stats.remoteJobs}`, centerX - 150, y + 75);

    // Generation date
    doc
      .fillColor(PdfGenerator.SECONDARY_COLOR)
      .fontSize(12)
      .text(`Generated: ${new Date().toLocaleDateString()}`, centerX - 100, y + 120, {
        width: 200,
        align: 'center',
      });

    // Add decorative elements
    doc
      .strokeColor(PdfGenerator.PRIMARY_COLOR)
      .lineWidth(2)
      .moveTo(centerX - 200, 400)
      .lineTo(centerX + 200, 400)
      .stroke();
  }

  /**
   * Generate executive summary
   */
  private static generateExecutiveSummary(
    doc: typeof PDFDocument.prototype,
    jobs: JobListing[],
  ): void {
    const stats = PdfGenerator.calculateDetailedStats(jobs);

    // Section title
    PdfGenerator.addSectionTitle(doc, 'Executive Summary');

    let y = 120;

    // Key metrics
    doc.fillColor('#000000').fontSize(12).text('Key Findings:', 50, y).fontSize(10);

    y += 25;

    // Summary points
    const summaryPoints = [
      `Found ${stats.totalJobs} job opportunities across ${stats.companiesCount} companies`,
      `${stats.remoteJobs} positions (${((stats.remoteJobs / stats.totalJobs) * 100).toFixed(1)}%) offer remote work`,
      `Average salary range: $${stats.avgSalaryMin.toLocaleString()} - $${stats.avgSalaryMax.toLocaleString()}`,
      `Most common employment type: ${stats.topEmploymentType}`,
      `Top hiring companies: ${stats.topCompanies
        .slice(0, 3)
        .map((c) => c.company)
        .join(', ')}`,
    ];

    summaryPoints.forEach((point, index) => {
      doc.text(`â€¢ ${point}`, 70, y + index * 18);
    });

    y += summaryPoints.length * 18 + 30;

    // Industry insights
    if (stats.salaryStats.currencies.USD && stats.salaryStats.currencies.USD > 0) {
      PdfGenerator.addSubsectionTitle(doc, 'Market Analysis', y);
      y += 25;

      doc
        .fontSize(10)
        .text(
          `Salary Analysis: ${stats.salaryStats.withSalary} of ${stats.totalJobs} positions include salary information`,
          70,
          y,
        )
        .text(
          `Geographic Distribution: ${stats.topLocations.length} unique locations identified`,
          70,
          y + 15,
        )
        .text(
          `Employment Types: ${Object.keys(stats.employmentTypes).length} different types available`,
          70,
          y + 30,
        );
    }
  }

  /**
   * Generate analytics section with visual elements
   */
  private static generateAnalytics(doc: typeof PDFDocument.prototype, jobs: JobListing[]): void {
    const stats = PdfGenerator.calculateDetailedStats(jobs);

    // Section title
    PdfGenerator.addSectionTitle(doc, 'Job Market Analytics');

    let y = 120;

    // Company distribution chart (simple bar representation)
    PdfGenerator.addSubsectionTitle(doc, 'Top Companies', y);
    y += 30;

    stats.topCompanies.slice(0, 8).forEach((company, index) => {
      const maxCount = stats.topCompanies[0]?.count || 1;
      const barWidth = (company.count / maxCount) * 200;

      // Company name
      doc
        .fontSize(9)
        .fillColor('#000000')
        .text(company.company, 70, y + index * 25 + 2, { width: 150 });

      // Bar
      doc
        .rect(230, y + index * 25, barWidth, 15)
        .fillColor(PdfGenerator.PRIMARY_COLOR)
        .fill();

      // Count
      doc.fillColor('#000000').text(company.count.toString(), 440, y + index * 25 + 2);
    });

    y += stats.topCompanies.slice(0, 8).length * 25 + 30;

    // Employment type distribution
    if (y < 600) {
      PdfGenerator.addSubsectionTitle(doc, 'Employment Types', y);
      y += 30;

      Object.entries(stats.employmentTypes).forEach(([type, count], index) => {
        const percentage = ((count / stats.totalJobs) * 100).toFixed(1);

        doc
          .fontSize(9)
          .fillColor('#000000')
          .text(`${type}: ${count} jobs (${percentage}%)`, 70, y + index * 18);
      });

      y += Object.keys(stats.employmentTypes).length * 18 + 20;
    }

    // Salary insights
    if (stats.salaryStats.withSalary > 0 && y < 650) {
      PdfGenerator.addSubsectionTitle(doc, 'Salary Insights', y);
      y += 25;

      doc
        .fontSize(10)
        .text(`Positions with salary: ${stats.salaryStats.withSalary} of ${stats.totalJobs}`, 70, y)
        .text(`Average minimum: $${stats.avgSalaryMin.toLocaleString()}`, 70, y + 15)
        .text(`Average maximum: $${stats.avgSalaryMax.toLocaleString()}`, 70, y + 30)
        .text(`Currencies: ${Object.keys(stats.salaryStats.currencies).join(', ')}`, 70, y + 45);
    }
  }

  /**
   * Generate job listings section
   */
  private static generateJobListings(
    doc: typeof PDFDocument.prototype,
    jobs: JobListing[],
    filters: PdfGeneratorOptions['filters'] = {},
  ): void {
    doc.addPage();
    PdfGenerator.addSectionTitle(doc, `Job Listings (${jobs.length} jobs)`);

    let y = 120;
    const pageHeight = doc.page.height - 100; // Account for margins

    jobs.forEach((job, index) => {
      // Check if we need a new page
      if (y > pageHeight - 150) {
        doc.addPage();
        y = 80;
      }

      // Job header
      doc
        .fillColor(PdfGenerator.PRIMARY_COLOR)
        .fontSize(12)
        .text(`${index + 1}. ${job.title}`, 50, y, { width: 400 });

      y += 20;

      // Company and location
      doc
        .fillColor('#000000')
        .fontSize(10)
        .text(`Company: ${job.company}`, 70, y)
        .text(`Location: ${job.location}${job.remote ? ' (Remote)' : ''}`, 70, y + 12);

      y += 30;

      // Salary if available
      if (job.salary) {
        doc.text(
          `Salary: $${job.salary.min?.toLocaleString()} - $${job.salary.max?.toLocaleString()} ${job.salary.currency} (${job.salary.period})`,
          70,
          y,
        );
        y += 15;
      }

      // Employment type
      doc.text(`Type: ${job.employmentType}`, 70, y);
      y += 15;

      // Description (truncated)
      if (filters.includeDescription !== false && job.description) {
        const description =
          job.description.length > 200
            ? `${job.description.substring(0, 200)}...`
            : job.description;

        doc
          .fillColor(PdfGenerator.SECONDARY_COLOR)
          .fontSize(9)
          .text(`Description: ${description}`, 70, y, { width: 450 });

        y += Math.ceil(description.length / 80) * 12 + 5;
      }

      // Requirements
      if (filters.includeRequirements !== false && job.requirements.length > 0) {
        doc
          .fillColor('#000000')
          .fontSize(9)
          .text(`Requirements: ${job.requirements.slice(0, 5).join(', ')}`, 70, y, { width: 450 });
        y += 15;
      }

      // Benefits
      if (filters.includeBenefits !== false && job.benefits.length > 0) {
        doc
          .fillColor(PdfGenerator.SUCCESS_COLOR)
          .fontSize(9)
          .text(`Benefits: ${job.benefits.slice(0, 3).join(', ')}`, 70, y, { width: 450 });
        y += 15;
      }

      // Source and date
      doc
        .fillColor(PdfGenerator.SECONDARY_COLOR)
        .fontSize(8)
        .text(
          `Source: ${job.source.site} | Posted: ${job.postedDate?.toLocaleDateString() || 'Unknown'}`,
          70,
          y,
        );

      y += 25;

      // Separator line
      if (index < jobs.length - 1) {
        doc
          .strokeColor('#e5e7eb')
          .lineWidth(1)
          .moveTo(50, y)
          .lineTo(doc.page.width - 50, y)
          .stroke();
        y += 20;
      }
    });
  }

  /**
   * Add section title
   */
  private static addSectionTitle(doc: typeof PDFDocument.prototype, title: string): void {
    doc.fillColor(PdfGenerator.PRIMARY_COLOR).fontSize(18).text(title, 50, 80);

    // Underline
    doc
      .strokeColor(PdfGenerator.PRIMARY_COLOR)
      .lineWidth(2)
      .moveTo(50, 105)
      .lineTo(50 + doc.widthOfString(title, { fontSize: 18 }) + 20, 105)
      .stroke();
  }

  /**
   * Add subsection title
   */
  private static addSubsectionTitle(
    doc: typeof PDFDocument.prototype,
    title: string,
    y: number,
  ): void {
    doc.fillColor(PdfGenerator.SECONDARY_COLOR).fontSize(14).text(title, 50, y);
  }

  /**
   * Add page footers
   */
  private static addFooters(doc: typeof PDFDocument.prototype): void {
    const pages = doc.bufferedPageRange();

    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(pages.start + i);

      // Page number
      doc
        .fillColor(PdfGenerator.SECONDARY_COLOR)
        .fontSize(10)
        .text(`Page ${i + 1} of ${pages.count}`, doc.page.width - 100, doc.page.height - 30, {
          align: 'right',
        });

      // Generated by
      doc.text('Generated by Job Dorker', 50, doc.page.height - 30, { align: 'left' });
    }
  }

  /**
   * Calculate basic statistics
   */
  private static calculateBasicStats(jobs: JobListing[]) {
    return {
      totalJobs: jobs.length,
      companiesCount: new Set(jobs.map((j) => j.company)).size,
      locationsCount: new Set(jobs.map((j) => j.location)).size,
      remoteJobs: jobs.filter((j) => j.remote).length,
    };
  }

  /**
   * Calculate detailed statistics for analytics
   */
  private static calculateDetailedStats(jobs: JobListing[]) {
    const stats = {
      totalJobs: jobs.length,
      companiesCount: new Set(jobs.map((j) => j.company)).size,
      locationsCount: new Set(jobs.map((j) => j.location)).size,
      remoteJobs: jobs.filter((j) => j.remote).length,
      employmentTypes: {} as Record<string, number>,
      topCompanies: [] as Array<{ company: string; count: number }>,
      topLocations: [] as Array<{ location: string; count: number }>,
      salaryStats: {
        withSalary: 0,
        currencies: {} as Record<string, number>,
      },
      avgSalaryMin: 0,
      avgSalaryMax: 0,
      topEmploymentType: 'full-time',
    };

    // Employment type distribution
    jobs.forEach((job) => {
      stats.employmentTypes[job.employmentType] =
        (stats.employmentTypes[job.employmentType] || 0) + 1;
    });

    // Top employment type
    stats.topEmploymentType =
      Object.entries(stats.employmentTypes).sort(([, a], [, b]) => b - a)[0]?.[0] || 'full-time';

    // Company frequency
    const companyCount = new Map<string, number>();
    jobs.forEach((job) => {
      companyCount.set(job.company, (companyCount.get(job.company) || 0) + 1);
    });
    stats.topCompanies = Array.from(companyCount.entries())
      .map(([company, count]) => ({ company, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Location frequency
    const locationCount = new Map<string, number>();
    jobs.forEach((job) => {
      locationCount.set(job.location, (locationCount.get(job.location) || 0) + 1);
    });
    stats.topLocations = Array.from(locationCount.entries())
      .map(([location, count]) => ({ location, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Salary statistics
    const jobsWithSalary = jobs.filter((j) => j.salary);
    stats.salaryStats.withSalary = jobsWithSalary.length;

    if (jobsWithSalary.length > 0) {
      const minSalaries = jobsWithSalary.map((j) => j.salary?.min).filter(Boolean) as number[];
      const maxSalaries = jobsWithSalary.map((j) => j.salary?.max).filter(Boolean) as number[];

      if (minSalaries.length > 0) {
        stats.avgSalaryMin = minSalaries.reduce((a, b) => a + b, 0) / minSalaries.length;
      }
      if (maxSalaries.length > 0) {
        stats.avgSalaryMax = maxSalaries.reduce((a, b) => a + b, 0) / maxSalaries.length;
      }

      // Currency distribution
      jobsWithSalary.forEach((job) => {
        if (job.salary) {
          const currency = job.salary.currency;
          stats.salaryStats.currencies[currency] =
            (stats.salaryStats.currencies[currency] || 0) + 1;
        }
      });
    }

    return stats;
  }

  /**
   * Validate PDF file
   */
  static async validatePdfFile(filePath: string): Promise<{
    valid: boolean;
    errors: string[];
    fileSize?: number;
  }> {
    try {
      const stats = await fs.stat(filePath);

      // Basic file existence and size check
      if (stats.size === 0) {
        return { valid: false, errors: ['PDF file is empty'] };
      }

      if (stats.size < 100) {
        return { valid: false, errors: ['PDF file appears to be corrupted (too small)'] };
      }

      // Read first few bytes to check PDF header
      const buffer = Buffer.alloc(10);
      const fileHandle = await fs.open(filePath, 'r');
      await fileHandle.read(buffer, 0, 10, 0);
      await fileHandle.close();

      if (!buffer.toString('ascii', 0, 4).startsWith('%PDF')) {
        return {
          valid: false,
          errors: ['File does not appear to be a valid PDF (missing PDF header)'],
        };
      }

      return {
        valid: true,
        errors: [],
        fileSize: stats.size,
      };
    } catch (error) {
      return {
        valid: false,
        errors: [
          `Failed to validate PDF: ${error instanceof Error ? error.message : 'Unknown error'}`,
        ],
      };
    }
  }
}
